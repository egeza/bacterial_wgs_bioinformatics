---
title: "Day 1: Bacterial WGS training"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Objectives
1. Describe key reasons for using shell
2. Navigate the file system using the command line
3. Access and read help files for bash programs and use the help function to identify useful command options
4. Use command line to navigate files and directories
5. Read and create, copy, move/rename files/directories
6. Search information in a file, print results of a command line to a file, construct command pipelines
7. Use for loops to run command for several input files
8. Write and execute a shell script (use of editors to modify files, use chmod to make a script executable)

# The Shell

We interact with a computer operating system (OS) in two ways:

 1. Graphical User Interface (GUI)
    - GUI is the most poular (default for most software, windows and Mac OS).
    - We see and interact with visual representation of files, folders and apps.
 2. Command Line Interface (CLI)
    - text representation of software, files, folders, input and output

## Reasons for using a shell
We use the shell for the following reasons:

 - Most bioinformatics tools are not GUI. In GUI tool features and parameters are not accessible, e.g BLAST.
 - Shell makes work reproducible: CLI keeps a record of every step one carries out, making easing the inspection application of same process to new data.
 - Repetitive work can be automated enhancing efficiency, simplifies testing of a wide range of parameters.
 - Minimizes errors - when humans do the same thing many times they are likely to make mistakes.
 - Enables easy access to remote computers or cloud computing.

## Accessing a shell

 - On a Mac or Linux machine - through a program called *Terminal* (already available on your computer). 
 - The Terminal - is a window into which we will type commands. 
 - On Windows - download a separate program, there are several but we use *Git Bash* (<https://git-scm.com/download/win>) for this training.

To save time and avoid storage problems, we are using a remote server <https://www.ilifu.ac.za/> where all the necessary data and software available. 
Today, We will learn the basics of the shell by manipulating some data files. 

# Accessing ilifu

 - Each participant have an **ilifu** user account.
 - Log-in to the remote server **ilifu** using 

```{bash login-ilifu, eval=FALSE}
ssh username@slurm.ilifu.ac.za
```

After logging in, you will see a screen showing something like this:
```{bash ilifu-login-interface, eval=FALSE}
Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 5.15.0-91-generic x86_64)
Last login: Mon Jul 29 03:09:35 2024 from 41.114.207.73

+---------------------------------------------------------------------+
|    _ _ _  __                                                        |
|   (_) (_)/ _|_  _     Welcome to the ilifu SLURM Cluster            |
|   | | | |  _| || |    Please familiarise yourself with the list     |
|   |_|_|_|_|  \_,_|    of recommendations below.                     |
|                                                                     |
| DOs:                                                                |
| * try run jobs using sbatch rather than interactive jobs            |
| * cleanup unused files when not needed                              |
| * set --time, --mem, --account parameters when submitting jobs,     |
|   accurate description of job parameters improves the performance   |
|   of the SLURM scheduler                                            |
|                                                                     |
| DO NOTs:                                                            |
| * run software on the login-node                                    |
| * transfer large data on the login-node, use transfer.ilifu.ac.za   |
|   (accessed via ssh) to do this                                     |
| * copy large files to /users directory                              |
| * leave data in /scratch3 as this space is limited. After           |
|   processing remove data that is not required and move files        |
|   to your project directory                                         |
|                                                                     |
| User documentation is available at https://docs.ilifu.ac.za/        |
|                                                                     |
| For any queries or if you need help please contact the support team |
| at support@ilifu.ac.za                                              |
|                                                                     |
| Please login to https://reports.ilifu.ac.za/ and make sure your     |
| account is up to date as well as to view usage summaries.           |
|                                                                     |
+---------------------------------------------------------------------+

Valid Slurm Accounts for user username on ilifu-slurm2021:
  b16-cbio-ag

Change your default account with:
  sacctmgr modify user name=username set DefaultAccount=<account>
Running job count: 0
Pending job count: 0

Run the "shelp" command to display this message.

username@slurm-login:~$
```

# Navigating your file system
The file system is part of the OS that manages files and directories. It organizes our data into files, which hold information, and directories (also called “folders”), which hold files or other directories.

Several commands are frequently used to create, inspect, rename, and delete files and directories.

```{bash dollar, eval=FALSE}
$
```
The dollar sign is a prompt, which shows us that the shell is waiting for input.
Your shell may use a different character as a prompt and may add information before the prompt. When typing commands, do not type the prompt, only the commands that follow it.

Let’s find out where we are by on the system  “print working directory”

```{bash pwd, eval=FALSE}
pwd
```


Let’s look at how our file system is organized by running ls, which stands for “listing”:

```{bash list-dir-contents, eval=FALSE}
ls
```


```{bash list-contents-course-data, eval=FALSE}
ls /cbio/training/courses/2024/bacterial_wgs/
```

**NOTE:** Anything with a “/” after it is a directory. Things with a “*” after them are programs. If there are no decorations, it’s a file.

ls has lots of other options. To find out what they are, we can type:

```{bash maual-ls, eval=FALSE}
man ls
```

man (short for manual) displays detailed documentation (also referred as man page or man file) for bash commands. Scroll through the file using the keyboard’s down arrow or use the Space key to go forward one page and the b key to go backwards one page. When you are done reading, hit q to quit.

The command to change locations in our file system is cd (“change directory”).
```{bash cd-command, eval=FALSE}
cd
```

## Key points
 - The shell facilitates efficiency by using CLI instead of GUI.
 - Useful commands for navigating the file system include: ls, pwd, and cd.
 - Most commands take options (flags) which begin with a -.
 - Tab completion can reduce errors from mistyping and make work more efficient in the shell.
 
## Relative and Full (or Absolute) path
Directories can be specified using either a relative path or a full absolute path. The directories on the computer are arranged into a hierarchy. The full path tells you where a directory is in that hierarchy. Navigate to the home directory, then enter the pwd command.
```{bash, eval=FALSE}
cd /users/username
pwd
```
This is the full name of your home directory. username is a directory in home which is a directory in /. More on root and home in the next section.
```{bash, eval=FALSE}
cd ~/
pwd
## Absolute
cd /users/ephie
pwd

# Relative
cd ../
pwd
## change wkdir 
cd ephie
```

**NOTE**
 - The /, ~, and .. characters represent important navigational shortcuts.
 - Hidden files and directories start with . and can be viewed using ls -a.
 - Relative paths specify a location starting from the current location, while absolute paths specify a location from the root of the file system.

# Working with files

The data for this training are bacterial isolates that were cultured and sequenced. Each isolate have two result files in fastq format.
```{bash, eval=FALSE}
cd /cbio/training/courses/2024/bacterial_wgs/data/data
# Wilcards
ls *.gz
ls *_R1_001.fastq.gz
```
* - a wildcard to represent any number of characters

## Exercise
Do each of the following tasks from your current directory using a single ls command for each:

 1. List all of the files in /cbio/training/courses/2024/bacterial_wgs/data/data that start with ‘101’.
 2. List all of the files in /cbio/training/courses/2024/bacterial_wgs/data/data that contain ‘6’.
 
```{bash, eval=FALSE}
pwd

echo *.gz
```

## Command history
 - Up and down arrow
 - A few more useful shortcuts: 
    - Ctrl+C.
    - Ctrl+L.
    - Ctrl+R will do a reverse-search through your command history. This is very useful.

## Examining Files
```{bash clone-repository, eval=FALSE}
git clone https://github.com/egeza/bacterial_wgs_bioinformatics.git
cd bacterial_wgs_bioinformatics
ls 
cd toydata
cat testfile_R1.fastq
```
*cat* is a terrific program, but when the file is really big, it can be annoying to use. The program, less, is useful for this case. less opens the file as read only, and lets you navigate through it. The navigation commands are identical to the man program.
```{bash less, eval=FALSE}
less tesftfile_R1.fastq
head tesftfile_R1.fastq
tail tesftfile_R1.fastq

head -n 2 tesftfile_R1.fastq
tail -n 2 tesftfile_R1.fastq
```

### key	action
Space	to go forward
b	to go backward
g	to go to the beginning
G	to go to the end
q	to quit

## Details on the FASTQ format
Although it looks complicated, the fastq format can be decoded using the following rules about the format:

 1. Each sequence entry consists of 4 lines
 2. Line	Description
    -	Always begins with ‘@’ and then information about the read
    -	The actual DNA sequence
    - Always begins with a ‘+’ and sometimes the same info in line 1
    - A string of characters which represent the quality scores; must have same number of characters as line 2

Let's view the first complete read in one of the files in our dataset by using head
```{bash first-4lines-file, eval=FALSE}
head -n 4 tesftfile_R1.fastq
```

